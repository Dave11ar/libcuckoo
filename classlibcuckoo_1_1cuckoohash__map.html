<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: libcuckoo::cuckoohash_map&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>libcuckoo</b></li><li class="navelem"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibcuckoo_1_1cuckoohash__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcuckoo::cuckoohash_map&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type Declarations</div></td></tr>
<tr class="memitem:a2a073819155af5a54bcfd223b074bb36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a073819155af5a54bcfd223b074bb36"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = typename buckets_t::key_type</td></tr>
<tr class="separator:a2a073819155af5a54bcfd223b074bb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bcc2c86c78f01e14e163ae47d2b5e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95bcc2c86c78f01e14e163ae47d2b5e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = typename buckets_t::mapped_type</td></tr>
<tr class="separator:a95bcc2c86c78f01e14e163ae47d2b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1342a4c43023a99d715c92af8ced3b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa1342a4c43023a99d715c92af8ced3b9">value_type</a> = typename buckets_t::value_type</td></tr>
<tr class="separator:aa1342a4c43023a99d715c92af8ced3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb707d780a40d98901cd3d55ee20c612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb707d780a40d98901cd3d55ee20c612"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename buckets_t::size_type</td></tr>
<tr class="separator:acb707d780a40d98901cd3d55ee20c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36711b5af6792f35e5808063967a3677"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36711b5af6792f35e5808063967a3677"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="separator:a36711b5af6792f35e5808063967a3677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28c964893eb0b141e33daef447ab7f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae28c964893eb0b141e33daef447ab7f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = Hash</td></tr>
<tr class="separator:ae28c964893eb0b141e33daef447ab7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213c5b0a598de025d7f4f7623ac36dbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a213c5b0a598de025d7f4f7623ac36dbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = KeyEqual</td></tr>
<tr class="separator:a213c5b0a598de025d7f4f7623ac36dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa2fe0581d1697c81016a2f684c6db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eaa2fe0581d1697c81016a2f684c6db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = typename buckets_t::allocator_type</td></tr>
<tr class="separator:a0eaa2fe0581d1697c81016a2f684c6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2a57f15254bbdac5fdf65637481c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ed2a57f15254bbdac5fdf65637481c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = typename buckets_t::reference</td></tr>
<tr class="separator:a6ed2a57f15254bbdac5fdf65637481c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094925b760ee307ca64b4c2714580cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a094925b760ee307ca64b4c2714580cea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = typename buckets_t::const_reference</td></tr>
<tr class="separator:a094925b760ee307ca64b4c2714580cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c6206ffd174301f5fe36bad3a26d79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09c6206ffd174301f5fe36bad3a26d79"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename buckets_t::pointer</td></tr>
<tr class="separator:a09c6206ffd174301f5fe36bad3a26d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe942dcce855767812a7556ee4413a8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe942dcce855767812a7556ee4413a8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename buckets_t::const_pointer</td></tr>
<tr class="separator:afe942dcce855767812a7556ee4413a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Destructors, and Assignment</div></td></tr>
<tr class="memitem:afd3f92eecacb37962b6cc332c22a081b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#afd3f92eecacb37962b6cc332c22a081b">cuckoohash_map</a> (size_type n=DEFAULT_SIZE, const Hash &amp;hf=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:afd3f92eecacb37962b6cc332c22a081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528a78ff632b863e866d9c26e9440270"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a528a78ff632b863e866d9c26e9440270"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a528a78ff632b863e866d9c26e9440270">cuckoohash_map</a> (InputIt first, InputIt last, size_type n=DEFAULT_SIZE, const Hash &amp;hf=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a528a78ff632b863e866d9c26e9440270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f1fc51550c0521ad818f42af644ce9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#af5f1fc51550c0521ad818f42af644ce9">cuckoohash_map</a> (const <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;other)=default</td></tr>
<tr class="separator:af5f1fc51550c0521ad818f42af644ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a53aa3445208d6dd682141deb9a42ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a2a53aa3445208d6dd682141deb9a42ee">cuckoohash_map</a> (const <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a2a53aa3445208d6dd682141deb9a42ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5b939ce92c31b783d3c070c59ef4fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a3e5b939ce92c31b783d3c070c59ef4fb">cuckoohash_map</a> (<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a3e5b939ce92c31b783d3c070c59ef4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94495a03be797633df63443d224b6af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa94495a03be797633df63443d224b6af">cuckoohash_map</a> (<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="separator:aa94495a03be797633df63443d224b6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2efb1b7cd1317c3645998cec1d4d4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a2c2efb1b7cd1317c3645998cec1d4d4d">cuckoohash_map</a> (std::initializer_list&lt; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa1342a4c43023a99d715c92af8ced3b9">value_type</a> &gt; init, size_type n=DEFAULT_SIZE, const Hash &amp;hf=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a2c2efb1b7cd1317c3645998cec1d4d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9f05af225c08d93c965da61726ea74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aee9f05af225c08d93c965da61726ea74">swap</a> (<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;other) noexcept</td></tr>
<tr class="separator:aee9f05af225c08d93c965da61726ea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0729444a9336cc10cbed32cfc04951b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a0729444a9336cc10cbed32cfc04951b1">operator=</a> (const <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;other)=default</td></tr>
<tr class="separator:a0729444a9336cc10cbed32cfc04951b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0898f24e271b33d95bd1996db99943e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a0898f24e271b33d95bd1996db99943e8">operator=</a> (<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a0898f24e271b33d95bd1996db99943e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ef5e1b36906e3d86d995c84ba9915d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a54ef5e1b36906e3d86d995c84ba9915d">operator=</a> (std::initializer_list&lt; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa1342a4c43023a99d715c92af8ced3b9">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a54ef5e1b36906e3d86d995c84ba9915d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table Details</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods for getting information about the table. Methods that query changing properties of the table are not synchronized with concurrent operations, and may return out-of-date information if the table is being concurrently modified. They will also continue to work after the container has been moved. </p>
</div></td></tr>
<tr class="memitem:a03c5cbc05588f5b38f7a4e2597550c64"><td class="memItemLeft" align="right" valign="top">hasher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a03c5cbc05588f5b38f7a4e2597550c64">hash_function</a> () const </td></tr>
<tr class="separator:a03c5cbc05588f5b38f7a4e2597550c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b541a9358e8cd38b120836e99a15f2"><td class="memItemLeft" align="right" valign="top">key_equal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#ac7b541a9358e8cd38b120836e99a15f2">key_eq</a> () const </td></tr>
<tr class="separator:ac7b541a9358e8cd38b120836e99a15f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4f834a815847e6526f32268d025650"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a9c4f834a815847e6526f32268d025650">get_allocator</a> () const </td></tr>
<tr class="separator:a9c4f834a815847e6526f32268d025650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a578f9bb1a0e52efb8595f18489cc56"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a0a578f9bb1a0e52efb8595f18489cc56">hashpower</a> () const </td></tr>
<tr class="separator:a0a578f9bb1a0e52efb8595f18489cc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf117626a5d7a7ca63a74e328d97909"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a9cf117626a5d7a7ca63a74e328d97909">bucket_count</a> () const </td></tr>
<tr class="separator:a9cf117626a5d7a7ca63a74e328d97909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b7f3eaa3a7429123f9cc05aa994b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a9f1b7f3eaa3a7429123f9cc05aa994b8">empty</a> () const </td></tr>
<tr class="separator:a9f1b7f3eaa3a7429123f9cc05aa994b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2322c453cf379c4456e94a3fdced6bd7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a2322c453cf379c4456e94a3fdced6bd7">size</a> () const </td></tr>
<tr class="separator:a2322c453cf379c4456e94a3fdced6bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010c8145c50c1d1c1d98457021bd0209"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a010c8145c50c1d1c1d98457021bd0209">capacity</a> () const </td></tr>
<tr class="separator:a010c8145c50c1d1c1d98457021bd0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ae36f196ffdeccda1df9daaa36565"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#ab56ae36f196ffdeccda1df9daaa36565">load_factor</a> () const </td></tr>
<tr class="separator:ab56ae36f196ffdeccda1df9daaa36565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff0b2be71812025c605d1e2ff9e6715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aeff0b2be71812025c605d1e2ff9e6715">minimum_load_factor</a> (const double mlf)</td></tr>
<tr class="separator:aeff0b2be71812025c605d1e2ff9e6715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c00e3ec28fe4857a185e6756933b89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a43c00e3ec28fe4857a185e6756933b89">minimum_load_factor</a> () const </td></tr>
<tr class="separator:a43c00e3ec28fe4857a185e6756933b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d97a4f777f08ddb0208e0d337ace3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a347d97a4f777f08ddb0208e0d337ace3">maximum_hashpower</a> (size_type mhp)</td></tr>
<tr class="separator:a347d97a4f777f08ddb0208e0d337ace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a43bf6ec51154b22dc0692f740c9ff"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a19a43bf6ec51154b22dc0692f740c9ff">maximum_hashpower</a> () const </td></tr>
<tr class="separator:a19a43bf6ec51154b22dc0692f740c9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f8f1151601469448ccdf7cd9c4150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#abf8f8f1151601469448ccdf7cd9c4150">max_num_worker_threads</a> (size_type extra_threads)</td></tr>
<tr class="separator:abf8f8f1151601469448ccdf7cd9c4150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7c9b373b4a6db20a4eea8e82115a78"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a7b7c9b373b4a6db20a4eea8e82115a78">max_num_worker_threads</a> () const </td></tr>
<tr class="separator:a7b7c9b373b4a6db20a4eea8e82115a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are operations that affect the data in the table. They are safe to call concurrently with each other. </p>
</div></td></tr>
<tr class="memitem:abf75612c0488f6d7df7d2bab7d228a2e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F &gt; </td></tr>
<tr class="memitem:abf75612c0488f6d7df7d2bab7d228a2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#abf75612c0488f6d7df7d2bab7d228a2e">find_fn</a> (const K &amp;key, F fn) const </td></tr>
<tr class="separator:abf75612c0488f6d7df7d2bab7d228a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a941f04ea416f44e1ede57e6b2073a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F &gt; </td></tr>
<tr class="memitem:a73a941f04ea416f44e1ede57e6b2073a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a73a941f04ea416f44e1ede57e6b2073a">update_fn</a> (const K &amp;key, F fn)</td></tr>
<tr class="separator:a73a941f04ea416f44e1ede57e6b2073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d60cdf9f67dc03ae42ae1e4cd7cec1a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F &gt; </td></tr>
<tr class="memitem:a6d60cdf9f67dc03ae42ae1e4cd7cec1a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a6d60cdf9f67dc03ae42ae1e4cd7cec1a">erase_fn</a> (const K &amp;key, F fn)</td></tr>
<tr class="separator:a6d60cdf9f67dc03ae42ae1e4cd7cec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4f385efb8f26a54e804f3a9fb051d7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F , typename... Args&gt; </td></tr>
<tr class="memitem:adb4f385efb8f26a54e804f3a9fb051d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#adb4f385efb8f26a54e804f3a9fb051d7">uprase_fn</a> (K &amp;&amp;key, F fn, Args &amp;&amp;...val)</td></tr>
<tr class="separator:adb4f385efb8f26a54e804f3a9fb051d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a68ae9715f6fd00b10bca480b885846"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a0a68ae9715f6fd00b10bca480b885846"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a0a68ae9715f6fd00b10bca480b885846">upsert</a> (K &amp;&amp;key, F fn, Args &amp;&amp;...val)</td></tr>
<tr class="separator:a0a68ae9715f6fd00b10bca480b885846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21770ce2cd67691af2f0b54b6457b27f"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a21770ce2cd67691af2f0b54b6457b27f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a21770ce2cd67691af2f0b54b6457b27f">find</a> (const K &amp;key, mapped_type &amp;val) const </td></tr>
<tr class="separator:a21770ce2cd67691af2f0b54b6457b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6668a7f0d7c793c6c35f389a12d8aa"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aaa6668a7f0d7c793c6c35f389a12d8aa"><td class="memTemplItemLeft" align="right" valign="top">mapped_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aaa6668a7f0d7c793c6c35f389a12d8aa">find</a> (const K &amp;key) const </td></tr>
<tr class="separator:aaa6668a7f0d7c793c6c35f389a12d8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893ecb7ab915ba3dc10e92abb9b58f8f"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a893ecb7ab915ba3dc10e92abb9b58f8f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a893ecb7ab915ba3dc10e92abb9b58f8f">contains</a> (const K &amp;key) const </td></tr>
<tr class="separator:a893ecb7ab915ba3dc10e92abb9b58f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7602ec2c0e8d503a111c562ddaaeefe"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ac7602ec2c0e8d503a111c562ddaaeefe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#ac7602ec2c0e8d503a111c562ddaaeefe">update</a> (const K &amp;key, V &amp;&amp;val)</td></tr>
<tr class="separator:ac7602ec2c0e8d503a111c562ddaaeefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524eea6240a40286678985634a50ebe6"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a524eea6240a40286678985634a50ebe6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a524eea6240a40286678985634a50ebe6">insert</a> (K &amp;&amp;key, Args &amp;&amp;...val)</td></tr>
<tr class="separator:a524eea6240a40286678985634a50ebe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b6870924bd9e7312aca991279b975f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a82b6870924bd9e7312aca991279b975f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a82b6870924bd9e7312aca991279b975f">insert_or_assign</a> (K &amp;&amp;key, V &amp;&amp;val)</td></tr>
<tr class="separator:a82b6870924bd9e7312aca991279b975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc02f0e4661ae4da5a557dabb472c6b"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:abdc02f0e4661ae4da5a557dabb472c6b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#abdc02f0e4661ae4da5a557dabb472c6b">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:abdc02f0e4661ae4da5a557dabb472c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b37f8d4e65f557a049ff3c495e0701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a30b37f8d4e65f557a049ff3c495e0701">rehash</a> (size_type n)</td></tr>
<tr class="separator:a30b37f8d4e65f557a049ff3c495e0701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1620ba0231a77799ce5a03f43f67a441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a1620ba0231a77799ce5a03f43f67a441">reserve</a> (size_type n)</td></tr>
<tr class="separator:a1620ba0231a77799ce5a03f43f67a441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f2789abf2445f12183ae5db1f51b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a653f2789abf2445f12183ae5db1f51b4">clear</a> ()</td></tr>
<tr class="separator:a653f2789abf2445f12183ae5db1f51b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a0ddfc9f1c7633a47ef34329d82623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a68a0ddfc9f1c7633a47ef34329d82623">lock_table</a> ()</td></tr>
<tr class="separator:a68a0ddfc9f1c7633a47ef34329d82623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Table Parameters</div></td></tr>
<tr class="memitem:a5b93abe6d3fb9db1478ef208b84d65e4"><td class="memItemLeft" align="right" valign="top">static constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a5b93abe6d3fb9db1478ef208b84d65e4">slot_per_bucket</a> ()</td></tr>
<tr class="separator:a5b93abe6d3fb9db1478ef208b84d65e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a65105a2e2b0f12a6782164d6ed0ba579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65105a2e2b0f12a6782164d6ed0ba579"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UnitTestInternalAccess</b></td></tr>
<tr class="separator:a65105a2e2b0f12a6782164d6ed0ba579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt;<br />
class libcuckoo::cuckoohash_map&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;</h3>

<p>A concurrent hash table</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>type of keys in the table </td></tr>
    <tr><td class="paramname">T</td><td>type of values in the table </td></tr>
    <tr><td class="paramname">Hash</td><td>type of hash functor </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>type of equality comparison functor </td></tr>
    <tr><td class="paramname">Allocator</td><td>type of allocator. We suggest using an aligned allocator, because the table relies on types that are over-aligned to optimize concurrent cache usage. </td></tr>
    <tr><td class="paramname">SLOT_PER_BUCKET</td><td>number of slots for each bucket in the table </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa1342a4c43023a99d715c92af8ced3b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa1342a4c43023a99d715c92af8ced3b9">value_type</a> =  typename buckets_t::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is defined as an <code>std::pair</code>. Note that table behavior is undefined if a user-defined specialization of <code>std::pair&lt;Key, T&gt;</code> or <code>std::pair&lt;const Key, T&gt;</code> exists. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afd3f92eecacb37962b6cc332c22a081b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>DEFAULT_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hf</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new cuckohash_map instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of elements to reserve space for initially </td></tr>
    <tr><td class="paramname">hf</td><td>hash function instance to use </td></tr>
    <tr><td class="paramname">equal</td><td>equality function instance to use </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a528a78ff632b863e866d9c26e9440270"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>DEFAULT_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hf</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs the map with the contents of the range <code></code>[first, last]. If multiple elements in the range have equivalent keys, it is unspecified which element is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the beginning of the range to copy from </td></tr>
    <tr><td class="paramname">last</td><td>the end of the range to copy from </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements to reserve space for initially </td></tr>
    <tr><td class="paramname">hf</td><td>hash function instance to use </td></tr>
    <tr><td class="paramname">equal</td><td>equality function instance to use </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5f1fc51550c0521ad818f42af644ce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. If <code>other</code> is being modified concurrently, behavior is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map being copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a53aa3445208d6dd682141deb9a42ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor with separate allocator. If <code>other</code> is being modified concurrently, behavior is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map being copied </td></tr>
    <tr><td class="paramname">alloc</td><td>the allocator instance to use with the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e5b939ce92c31b783d3c070c59ef4fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. If <code>other</code> is being modified concurrently, behavior is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map being moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa94495a03be797633df63443d224b6af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor with separate allocator. If the map being moved is being modified concurrently, behavior is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map being moved </td></tr>
    <tr><td class="paramname">alloc</td><td>the allocator instance to use with the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c2efb1b7cd1317c3645998cec1d4d4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa1342a4c43023a99d715c92af8ced3b9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>DEFAULT_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hf</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs the map with the contents of initializer list <code>init</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the map with </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements to reserve space for initially </td></tr>
    <tr><td class="paramname">hf</td><td>hash function instance to use </td></tr>
    <tr><td class="paramname">equal</td><td>equality function instance to use </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9cf117626a5d7a7ca63a74e328d97909"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of buckets in the table.</p>
<dl class="section return"><dt>Returns</dt><dd>the bucket count </dd></dl>

</div>
</div>
<a class="anchor" id="a010c8145c50c1d1c1d98457021bd0209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current capacity of the table, that is, <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a9cf117626a5d7a7ca63a74e328d97909">bucket_count()</a> &times; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a5b93abe6d3fb9db1478ef208b84d65e4">slot_per_bucket()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>capacity of table </dd></dl>

</div>
</div>
<a class="anchor" id="a653f2789abf2445f12183ae5db1f51b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements in the table, calling their destructors. </p>

</div>
</div>
<a class="anchor" id="a893ecb7ab915ba3dc10e92abb9b58f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not <code>key</code> is in the table. Equivalent to <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#abf75612c0488f6d7df7d2bab7d228a2e">find_fn</a> with a functor that does nothing. </p>

</div>
</div>
<a class="anchor" id="a9f1b7f3eaa3a7429123f9cc05aa994b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the table is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the table is empty, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abdc02f0e4661ae4da5a557dabb472c6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases the key from the table. Equivalent to calling <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a6d60cdf9f67dc03ae42ae1e4cd7cec1a">erase_fn</a> with a functor that just returns true. </p>

</div>
</div>
<a class="anchor" id="a6d60cdf9f67dc03ae42ae1e4cd7cec1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::erase_fn </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for <code>key</code> in the table, and invokes <code>fn</code> on the value if the key is found. The functor can mutate the value, and should return <code>true</code> in order to erase the element, and <code>false</code> otherwise.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>type of the key </td></tr>
    <tr><td class="paramname">F</td><td>type of the functor. It should implement the method <code>bool operator()(mapped_type&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to possibly erase from the table </td></tr>
    <tr><td class="paramname">fn</td><td>the functor to invoke if the element is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>key</code> was found and <code>fn</code> invoked, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a21770ce2cd67691af2f0b54b6457b27f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mapped_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the value associated with <code>key</code> into <code>val</code>. Equivalent to calling <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#abf75612c0488f6d7df7d2bab7d228a2e">find_fn</a> with a functor that copies the value into <code>val</code>. <code>mapped_type</code> must be <code>CopyAssignable</code>. </p>

</div>
</div>
<a class="anchor" id="aaa6668a7f0d7c793c6c35f389a12d8aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mapped_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the table for <code>key</code>, and returns the associated value it finds. <code>mapped_type</code> must be <code>CopyConstructible</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>type of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value associated with the given key </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the key is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf75612c0488f6d7df7d2bab7d228a2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::find_fn </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the table for <code>key</code>, and invokes <code>fn</code> on the value. <code>fn</code> is not allowed to modify the contents of the value if found.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>type of the key. This can be any type comparable with <code>key_type</code> </td></tr>
    <tr><td class="paramname">F</td><td>type of the functor. It should implement the method <code>void operator()(const mapped_type&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to search for </td></tr>
    <tr><td class="paramname">fn</td><td>the functor to invoke if the element is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key was found and functor invoked, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4f834a815847e6526f32268d025650"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the allocator associated with the map</p>
<dl class="section return"><dt>Returns</dt><dd>the associated allocator </dd></dl>

</div>
</div>
<a class="anchor" id="a03c5cbc05588f5b38f7a4e2597550c64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hasher <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that hashes the keys</p>
<dl class="section return"><dt>Returns</dt><dd>the hash function </dd></dl>

</div>
</div>
<a class="anchor" id="a0a578f9bb1a0e52efb8595f18489cc56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::hashpower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the hashpower of the table, which is log<sub>2</sub>(<a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a9cf117626a5d7a7ca63a74e328d97909">bucket_count()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>the hashpower </dd></dl>

</div>
</div>
<a class="anchor" id="a524eea6240a40286678985634a50ebe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts the key-value pair into the table. Equivalent to calling <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a0a68ae9715f6fd00b10bca480b885846">upsert</a> with a functor that does nothing. </p>

</div>
</div>
<a class="anchor" id="a82b6870924bd9e7312aca991279b975f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts the key-value pair into the table. If the key is already in the table, assigns the existing mapped value to <code>val</code>. Equivalent to calling <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a0a68ae9715f6fd00b10bca480b885846">upsert</a> with a functor that assigns the mapped value to <code>val</code>. </p>

</div>
</div>
<a class="anchor" id="ac7b541a9358e8cd38b120836e99a15f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">key_equal <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that compares keys for equality</p>
<dl class="section return"><dt>Returns</dt><dd>the key comparison function </dd></dl>

</div>
</div>
<a class="anchor" id="ab56ae36f196ffdeccda1df9daaa36565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the percentage the table is filled, that is, <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a2322c453cf379c4456e94a3fdced6bd7">size()</a> &divide; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a010c8145c50c1d1c1d98457021bd0209">capacity()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>load factor of the table </dd></dl>

</div>
</div>
<a class="anchor" id="a68a0ddfc9f1c7633a47ef34329d82623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a> <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::lock_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a> object that owns all the locks in the table.</p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a> instance </dd></dl>

</div>
</div>
<a class="anchor" id="abf8f8f1151601469448ccdf7cd9c4150"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::max_num_worker_threads </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>extra_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum number of extra worker threads the table can spawn when doing large batch operations. Currently batch operations occur in the following scenarios.</p><ul>
<li>Any resizing operation which invokes cuckoo_expand_simple. This includes any explicit rehash/resize operation, or any general resize if the data is not nothrow-move-constructible.</li>
<li>Creating a <a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a> or resizing within a <a class="el" href="classlibcuckoo_1_1cuckoohash__map_1_1locked__table.html">locked_table</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>the number of extra threads </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b7c9b373b4a6db20a4eea8e82115a78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::max_num_worker_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of extra worker threads. </p>

</div>
</div>
<a class="anchor" id="a347d97a4f777f08ddb0208e0d337ace3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::maximum_hashpower </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>mhp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the maximum hashpower the table can be. If set to NO_MAXIMUM_HASHPOWER, there will be no limit on the hashpower. Otherwise, the table will not be able to expand beyond the given hashpower, either by an explicit or an automatic expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhp</td><td>the hashpower to set the maximum to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the current hashpower exceeds the limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19a43bf6ec51154b22dc0692f740c9ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::maximum_hashpower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum hashpower of the table</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum hashpower </dd></dl>

</div>
</div>
<a class="anchor" id="aeff0b2be71812025c605d1e2ff9e6715"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::minimum_load_factor </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mlf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the minimum load factor allowed for automatic expansions. If an expansion is needed when the load factor of the table is lower than this threshold, <a class="el" href="classlibcuckoo_1_1load__factor__too__low.html">load_factor_too_low</a> is thrown. It will not be thrown for an explicitly-triggered expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mlf</td><td>the load factor to set the minimum to </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the given load factor is less than 0.0 or greater than 1.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43c00e3ec28fe4857a185e6756933b89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::minimum_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the minimum load factor of the table</p>
<dl class="section return"><dt>Returns</dt><dd>the minimum load factor </dd></dl>

</div>
</div>
<a class="anchor" id="a0729444a9336cc10cbed32cfc04951b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&amp; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment operator. If <code>other</code> is being modified concurrently, behavior is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a0898f24e271b33d95bd1996db99943e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&amp; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. If <code>other</code> is being modified concurrently, behavior is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a54ef5e1b36906e3d86d995c84ba9915d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&amp; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#aa1342a4c43023a99d715c92af8ced3b9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializer list assignment operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an initializer list to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a30b37f8d4e65f557a049ff3c495e0701"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the table to the given hashpower. If this hashpower is not larger than the current hashpower, then it decreases the hashpower to the maximum of the specified value and the smallest hashpower that can hold all the elements currently in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the hashpower to set for the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the table changed size, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1620ba0231a77799ce5a03f43f67a441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserve enough space in the table for the given number of elements. If the table can already hold that many elements, the function will shrink the table to the smallest hashpower that can hold the maximum of the specified amount and the current table size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of elements to reserve space for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size of the table changed, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2322c453cf379c4456e94a3fdced6bd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the table.</p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the table </dd></dl>

</div>
</div>
<a class="anchor" id="a5b93abe6d3fb9db1478ef208b84d65e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr uint16_t <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::slot_per_bucket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of slots per hash bucket </p>

</div>
</div>
<a class="anchor" id="aee9f05af225c08d93c965da61726ea74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exchanges the contents of the map with those of <code>other</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the map to exchange contents with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7602ec2c0e8d503a111c562ddaaeefe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the value associated with <code>key</code> to <code>val</code>. Equivalent to calling <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#a73a941f04ea416f44e1ede57e6b2073a">update_fn</a> with a functor that assigns the existing mapped value to <code>val</code>. <code>mapped_type</code> must be <code>MoveAssignable</code> or <code>CopyAssignable</code>. </p>

</div>
</div>
<a class="anchor" id="a73a941f04ea416f44e1ede57e6b2073a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::update_fn </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the table for <code>key</code>, and invokes <code>fn</code> on the value. <code>fn</code> is allow to modify the contents of the value if found.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>type of the key. This can be any type comparable with <code>key_type</code> </td></tr>
    <tr><td class="paramname">F</td><td>type of the functor. It should implement the method <code>void operator()(mapped_type&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to search for </td></tr>
    <tr><td class="paramname">fn</td><td>the functor to invoke if the element is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key was found and functor invoked, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adb4f385efb8f26a54e804f3a9fb051d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename F , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::uprase_fn </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for <code>key</code> in the table. If the key is found, then <code>fn</code> is called on the existing value, and nothing happens to the passed-in key and values. The functor can mutate the value, and should return <code>true</code> in order to erase the element, and <code>false</code> otherwise. If the key is not found and must be inserted, the pair will be constructed by forwarding the given key and values. If there is no room left in the table, it will be automatically expanded. Expansion may throw exceptions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>type of the key </td></tr>
    <tr><td class="paramname">F</td><td>type of the functor. It should implement the method <code>bool operator()(mapped_type&amp;)</code>. </td></tr>
    <tr><td class="paramname">Args</td><td>list of types for the value constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to insert into the table </td></tr>
    <tr><td class="paramname">fn</td><td>the functor to invoke if the element is found. If your <code>fn</code> needs more data that just the value being modified, consider implementing it as a lambda with captured arguments. </td></tr>
    <tr><td class="paramname">val</td><td>a list of constructor arguments with which to create the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a new key was inserted, false if the key was already in the table </dd></dl>

</div>
</div>
<a class="anchor" id="a0a68ae9715f6fd00b10bca480b885846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, std::size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename F , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html">libcuckoo::cuckoohash_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, SLOT_PER_BUCKET &gt;::upsert </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to calling <a class="el" href="classlibcuckoo_1_1cuckoohash__map.html#adb4f385efb8f26a54e804f3a9fb051d7">uprase_fn</a> with a functor that modifies the given value and always returns false (meaning the element is not removed). The passed-in functor must implement the method <code>void operator()(mapped_type&amp;)</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
